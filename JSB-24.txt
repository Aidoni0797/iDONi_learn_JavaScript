Энумерабельность и итерабельность

Это свойства ключей и значений объекта (метасвойства, свойства свойств). Вот каким образом можно 
представить из различие:

Ключи и значения в объекте соответствуют именам и сущностям.

Энумерабельность: доступны имена, а через них - сущности (литеральный объект, энумерабелен и не 
итерируем, есть for ... in нет for ... of)
задаётся метасвойством (атрибутом ключа)

Итерабельность: доступны сущности, и не через имена, а путём продвижения / обхода
(обычный массив: энумерабелен и итерируем есть и for ... in и for ... of)

задаётся специальным методом Symbol.iterator

Если создать объект литералом:
const o = {first: 'Elias', last:'Goss'};
то мы можем перечислить его ключи (first и last) с помощью for .. in:
for (let k in o) console.log(k);

Чтобы создать ключ методом метапрограммирования, мы должны явно указать, хотим ли мы, чтобы он был перечислим:
Reflect.defineProperty(o,'age',{value:44, enumerable:true});
В консоли node мы можем получить все (собственные, т.е. содержащииеся не в прототипе объекта, 
а в нём самом) ключи: require('util').format('%o',o).
В рассматриваемом случае, если мы хотим увидеть и несобственные ключи, то должны написать 
require('util').format('%0', Object.prototype)
При изучении темы ключей объектов может возникнуть сложность из-за того, что слово in по-разному
ведёт себя:
- как оператор (показывает не энумерабельный ключ);
- как часть цикла (не показывает не энумерабельный ключ, хотя может и показывать, если несобственное,
поэтому ключ length показывается в for ... in у структуры NodeList - оно не сделано неэнумерабельным
и оно несобственное, см. https://kodaktor.ru/enuml_arrays).