Третий вариант не должен встречаться до объявления, хотя и не вызывает ошибки (без включения
строгого режима "se strict"). Присваивание без объявления создаёт не столко переменную, сколько
конфигурируемое (удаляемое) свойство глобального объекта:
a = 5;
console.log(global a); //5
colsole.log(a); //5
delete a;
console.log(global a);//undefined
console.log(a);//ReferenceError: a is not defined

В строгом режиме ошибка возникнет раньше, потому что налицо попытка оперировать незафиксированным именем.
Попытка упоминания необъявленной переменной приводит к ошибке ReferenceError:... is not defined ...
в случаях, кроме упоминания после оператора typeof. Этот оператор возвращает undefined не только для
объявленных без присвоения переменных, но и для необъявленных переменных...
console.log(typeof b);
let b;
... кроме случая, представленного в примере. Если убрать содержимое второй строки, будет выдано underfined
иначе программа прервётся с ошибкой ReferenceError. Такое поведение называется temperory dead zone (TDZ)
т.е. временной мёртвой зоной. Возможно, оно кажется не очень логичным, но логика проясняется, если знать,
что слово var в таких случаях обеспечивает подъём.
Объявление с присваиванием - это, по-видимому, наиболее частый и корректный случай. Рассмотрим его
(и само присваивание) подробнее.
let message = 'hello';
//выражение присваивания возвращат 'hello' т.е. правостороннее выражение
Присваивание - это выражение, получаемое с помощью оператора присваивания, который выглядит как знак
равенства. Слева от знака равенства находится левосторонное выражение, а справа правостороннее. Примеры
левосторонних выражений: имя, выражение с уточнением, выражение с индексацией, выражение с
деструктуризацией (фигурным и/или квадратными скобками). Вычисление выражения присваивания возвращает
результат вычисления правостороннего выражения. То есть оператор присваивания правоассоциативен
(см. ниже о тернарном операторе!)
Если в правостороннем выражении применяется оператор "запятая", который объединяет в список несколько
выражений присваивания, то возвращается результат самого правого.
let
a = 3;
b = 4;
//const result=a=4, b=3
//SyntaxError: Identifier 'b' has already been deeclared
const result = (a=44, b=33);
console.log('${a}${b}${result}'); // 44 33 33
В формальных документах для определения таких понятий испоьзуются грамматические конструкции типа формы
Бэкуса - Наура и соответствующие им синтаксические диаграммы, например в стиле Д.Крокфорда:

Объявление с присваиванием: форма Бэкуса - Наура
Тот факт, что в результате вычисления выражения происходит влияние на состояние программы, называется
побочным эффектом выражения. Побочный эффект присваивания заключается в том, что меняется значение
переменной, т.е. получается, что главное назначение присваивания оказывается его побочным эффектом.
Выражение присваивания может рассматриваться как самостоятельная инструкция (expression statement),
в этом случае предпологается, что ранее имело место объявление, а теперь происходит переприсваивание.
Объявление без присваивания создаёт имя, с которым связывается значение underfined. Условно можно считать
что это объявление с присваиванием значения underfined. В современном JavaScript оно доступно только
с помощью слова let.
Присваивание можно рассматривать как изменение в той области памяти, которая ассоциирована с данным
именем при объявлении, но если правосторонее выражение есть null, то уместнее считать, что происходит
разрыв связи имени и этой области.
https://kodaktor.ru/underfined
Что такое область видимости?
Это границ (scope), в пределах которых доступна объявленная переменная. JavaScript всегда имел тенденцию 
рассматривать функцию (глава 4) как основной строительный блок программы. Вообще блок - это фрагмент
между открывающей и закрывающей фигурными скобками. Функция как блок в JavaScript традиционно играла
особую роль изолятора имён, т.е. переменные, объявленные с помощю слова var в блоке, объявленном 
с помощью слова function, не видны за пределами этого блока (хотя они видны для вложенных функциональных
блоков, разумеется). Ситуация с тех пор сильно изменилась в смысле усиления роли блока как такового 
независимо  от слова function.
Глобальные переменные - те, что объявлены на верхнем уровне (в рамках рассматриваемого кода). Количество
глобальных переменных должно быть сведено к минимуму, в идеале - к нулю.
Объявления переменных с помощью слова var интерпретируются, как если бы они находились в начале функции
(или глобальной области видимости, если объявление находится за пределами функции), независимо от того, где 
фактически находится объявление; этот эффект носит название, поднятие переменных (hosting: значение,
если присвоено, остаётся в той строке (и ниже), где присвоено, а вот имя вместе с underfined поднимается
наверх).
Объявления на уровне блока создают привязки (переменные), недоступные за пределами блока. Область
видимости блока (block scopes), которую также называют лексической областью видимости (lexical scopes)
благодаря словам let и const - уравнена в правах с функциональной областью видимости. Пример "армия
функций" (https://kodaktor.ru/army) хорошо показывает работу этой концепции, но задействует понятия,
которые рассматриваются в главах 4, 5 и 6, поэтому мы вернёмся к нему позднее.