Строки и массивы

Строки и массивы имеют некоторые совпадающие характеристики и множество различающих. Строка представляет
собой последовательность символов, а массив - последовательность значений происвольного типа. И строки,
и массивы позволяют обращаться к своим частям с помощью оператора индексации, индексы отсчитываются
от 0. Строки и массивы имеют свойство length, содержащее длину строки или количество элементов массива.
Литерал строки ограничивается кавычками, а литерал массива - квадратными скобками.

const first = 'Elias';
const last = 'Goss';
for (const t of first) console.log(t);
for (const t of last) console.log(t);

Цикл for ... in в этом контексте оказывается излишним (подробнее в главе 7).

Вместо императивных структур, где возможно удобно пользоваться функциональными:

const person = [first, last];
person.forEach((x,i)=>console.log(`${i} ${x}`));
//0 Elias
//1 Goss

В отличие от строк, массивы наследуют метод forEach, который принимает коллбэк, вызываемый для каждого
элемента массива. Этот метод возвращает underfined, не поддерживает таким образом цепочку методов и
не мутирует (сам по себе) перебираемый массив.
В отличие от иммутабельных строк (нельзя изменить какую-то часть строки, как бы подставив вместо
одного символа другой, можно только создать новую строку по исходной), массивы, естественно,
поддерживают возможность изменять себя по частям. В ряде случаев это как раз нежелательно поэтому
нужно обращать внимание на то, как работает тот или иной метод.
В отличие от строк, являющихся примитивным типом данных, массивы относятся к ссылочному типу. Массивы
являются подвидном объектов, о которых см. в главе 7 (о конструкторе, прототипах см в главе 8).
Какова связь ссылочных типов данных и так называемой реактивности?

let arrayOne = [1,2];
const refToArrayOne = arrayOne;
console.log(refToArrayOne[0]);
console.log(arrayOne[0]);
arrayOne[0] = 3;
console.log(refToArrayOne[0]);
console.log(arrayOne[0]);
arrayOne = [11,12];
console.log(refToArrayOne[0]);
console.log(arrayOne[0]);

Начиная со строки 3 и далее до строки 10, имён arrayOne и refToArrayOne нарушилась, так как 
правостороннее выражение [11,12] создаёт новую область памяти и связывает имя arrayOne с ней.
А имя refToArrayOne остаётся связанным со старой областью памяти. Если бы имя refToArrayOne
не хранило ссылку на эту область, то после строки 10 у интерпретатора появился бы повод передать
массив [1,2] в руки коллектора мусора.