Глава 8. Прототипы и конструкторы

Как уже говорилось в главе 7, при создании литерального объекта автоматически создаётся ещё один
объект, который называется прототипом. Но это касается всех сущностей, которые относятся к объектам.
Более того, это относится и к примитивным типам данных.
Например, когда мы создаём переменную, которой присваиваем строковое значение, мы можем сразу 
обратиться к её свойству length или методу includes. Но свойство есть только у объектов. Но при 
обращении к строке как к объекту происходит создание объекта-обёртки. И у этого объекта есть 
прототип, содержащий метод includes:

const first = 'Elias';
console.log(first.includes('li'));//true
console.log(first.includes('ea'));//false
//вызов через прототип
console.log(String.prototype.includes.call(first,'li');//true
console.log(String.prototype.includes.call(first,'ea');//false
console.log(Reflect.apply.call(null, String.prototype,includes, first, ['li'])); //true
console.log(Reflect.apply.call(null, String.prototype.includes, first, ['ea'])); //false

Выше показаны три способа обращения к методу includes;
- прямой
- косвенный
- метапрограммистский
По способу указания в справочных метариалах можно быстро понять, находится ли ключ в прототипе всех 
объектов данного класса или только в самом классе:

Запись типа Object.prototype.propertyIsEnumerable означает, что вызывать метод propertyIsEnumerable
нужно уточнением конкретного объекта. Запись типа Object.getOwnPropertyNames означает, что 
вызывать метод нужно ровно как он представлен, передавая ему нужные аргументы (включая конкретный
объект).
Объекты обёртки создаются, как уже было сказано выше, автоматически. Основной для их создания
являются конструкторы (String, Number, Boolean - это функции, спроектированные как конструкторы).
Всегда можно обратиться к ним в явной форме: просто вызвав эти функции, передав им в качестве
аргумента литерал строки или значение, которое булет преобразовано в строку. Поскольку, это именно
конструкторы, их можно вызвать с помощью оператора new (т.е. экземплификацией, см. модели вызова функций
в главе 4). Однако конкретно в случае с конструкторами обёрток это считается нерекомендованной практикой
(https://eslint.org/docs/rules/no-nw-wrappers).
Конструктор - это функция, объявленная с помощью слова function (не стрелочная), про которую 
предпологается, что она будет основой для создания объектов некоторой одинаковой структуры.
Соответственно, чтобы это имело смысл, такая функция должна эту структуру создавать, 
а следовательно, она должна быть заранее спроектирована в аспекте свойств (и методов).
Вызов конструктора осуществляется с оператором new. Если конструктор предпологает наличие аргументов,
то вызов сопровождается скобками, но рекомендуется использовать скобки в любом случаен 
(https://eslint.org/docs/rules/new-parens).
Функция может определить факт вызова с ключевым словом new, и для этого ES2015 определяет 
метасвойство new.target. Метасвойство - это необъективное свойство с дополнительной информацией
о его цели (такой, как new). Целью обячно является конструктор вновь созданного экземпляра
объекта, который будет присвоен ссылке this в теле функции. То есть new. target - это ссылка на
функцию, вызванную с ключевым словом new. При вызове с помощью call или apply new.target получает 
значение underfined. Метасвойство new.target можно также использовать в конструкторах классов,
чтобы определить, как вызвался класс. В простейшем случае new.target содержит ссылку на функцию-конструктор
класса.
Ничто не мешает использовать произвольную function-функцию в роли конструктора, но это в целом не 
особенно полезно:
const Cube = function(x) {return x**3;};
const cb = new Cube(5);
console.log(cb); // Cube {}
console.log(cb.constructor); // [Function: Cube]

Свойство constructir, доступное в новом объекте (оно содержится в его прототипе), позволяет
определить, какая функция была вызвана как конструктор для этого объекта.

В частности, это может быть анонимная функция:
/*eslint new-parens:0*/
const cb = new function() {return {first:'Elias'};};
console.log(cb); // {first:'Elias'}
console.log(cb.constructor); //[Function:Object]

Как видно из примера выше, если конструктор возвращает объект, то он и является тем, что
возвращает оператор экземплификации.
Если конструктор не возвращает объект, то создаётся новый объект, который должен был бы 
заполняться свойствами в рамках конструктора, и в следующем примере он получается пустым:

/*eslint new-parens: 0 */
const cb = new function(){};
console.log(cb); // {}
console.log(cb.constructor); //[Function]

Каким же образом конструктор должен заполнять структуру вновь создаваемого объекта?
Когда объект создаётся (т.е. когда конструктор не возвращает объект), он доступен внутри конструктора
через слово this. Он тогда будет тем объектом, который возвращает оператор экземплификации.

const Cube = function(x) {this.x = x;};
const cb = new Cube(5);
console.log(cb); //Cube {x:5}
console.log(cb.constructor); //[Function: Cube]

Таким образом, у объекта cb теперь есть свойство х с некоторым значением. Чтобы объект оправдывал 
своё название объекта, у него должны быть методы.
Методы принято добавлять не в теле конструктора, а отдельно, записывая их в качестве свойств объекта,
доступного через свойство prototype функции-конструктора.

const Cube = function(x) {this.x = x;};
Cube.prototype.volume = function(){return this.x**3;};
const cb = new Cube(5);
console.log(cb);//Cune{x:5}
console.log(cb.constructor); //[Function: Cube]
console.log(cb.volume()); //125

Такое обращение с методами объясняется тем, что значения свойств у каждого конкретного объекта
предпологаются своими, а методы нет никакой нужды копировать в конкретный объект.