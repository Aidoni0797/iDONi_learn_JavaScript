Наведения порядка в данных

А вот это уже сложнее. Нужно не только отобрать максимальные результаты, но и выбрать среди них результат
с наименьшими затратами?

Джуди: Максимальный результат мы уже знаем.
Фрэнк: Верно, но как его использовать? И у нас есть два массива. Как организовать их совместную работу?
Джуди: Думаю, любой из нас легко напишет простой цикл for, который снова перебирает массив scores и 
выбирает элементы с максимальным результатом.
Фрэнк: Да, это нетрудно. Но что потом?
Джуди: Каждый раз, когда находится результат, совпадающий с максимальным, мы проверяем, являются ли затраты
на его производство наименьшими из всех найденных.
Фрэнк: Ага, понятно, нам понадобится переменная для хранения индекса максимального результата с
минимальными затратами. попробуй сама.
Джуди: Именно. И после перебора всего массива в переменной окажется индекс образца, который не только 
имеет максимальный результат, но и требует наименьших затрат.
Фрэнк: А если у двух образцов будут одинаковые затраты?
Джуди: Хмм... Надо подумать, что делать в таких случаях. Я бы поступила просто: выбираем первый из найденных
образцов. Конечно, можно придумать более сложный критерий, но давай придерживаться этого варианта, если директор
не будет возражать.
Фрэнк: Как все сложно... Пожалуй, нам стоит набросать псевдокод, прежде чем браться за программу.
Джуди: Согласна: управление индексами нескольких массивов сильно усложняет дело. Давай так и сделаем. Если подумать
о будущем, планирование сэкономит нам время.
Фрэнк: Давай, я тут уже сделал первые наброски...
